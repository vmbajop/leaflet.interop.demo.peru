<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <title>Visor Leaflet Perú</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Favicon -->
    <link rel="icon" href="/libs/leaflet/favicon.ico" type="image/x-icon" />
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="/libs/leaflet/leaflet.css" />
    <link rel="stylesheet" href="/estilos/local.css" />
</head>
<body>
    <div id="map"></div>
    <!-- Leaflet JS -->
    <script src="/libs/leaflet/leaflet.js"></script>
    <!-- Proj4JS for projections -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <!-- Proj4Leaflet -->
    <script src="https://unpkg.com/proj4leaflet"></script>
    <!-- turf.js -->
    <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script>
        /* Mapa y capa base */
        var map = L.map('map').setView([-9.19, -75.0152], 6);
        
        // #region EVENTOS DE MAPA map.on()
        map.on('mousemove', updateCoords);
        //Dejo esta función para que se pueda usar en el futuro
        map.on('layerremove', function(e) {
            for (var key in overlays) {
                if (overlays[key] === e.layer) {
                    delete overlays[key];
                    updateLayerControl();
                    break;
                }
            }
        });

        /* Actualiza el control de capas cuando se agrega una nueva capa.
         * Se llama  al agregar una capa GeoJSON o WMS.
         * @param {Object} e - Evento de adición de capa.
         * @returns {void}
         */
        map.on('layeradd', function(e) {
            updateLayerControl();
        });
        // #endregion

        var basemaps = addBasemaps();
        basemaps["OpenStreetMap"].addTo(map); // Añadir OSM por defecto

        // Cambia a "Mixta" al hacer zoom a determinada escala (por ejemplo, zoom >= 14)
        /*map.on('zoomend', function() {
            var currentZoom = map.getZoom();
            if (currentZoom >= 14) {
            if (!map.hasLayer(basemaps["Mixta"])) {
                // Quita otras bases
                Object.values(basemaps).forEach(function(layer) {
                if (map.hasLayer(layer)) map.removeLayer(layer);
                });
                basemaps["Mixta"].addTo(map);
            }
            } else {
            if (!map.hasLayer(basemaps["OpenStreetMap"])) {
                Object.values(basemaps).forEach(function(layer) {
                if (map.hasLayer(layer)) map.removeLayer(layer);
                });
                basemaps["OpenStreetMap"].addTo(map);
            }
            }
        });*/

        /* LayerControl */
        var overlays = {};
        var layerControl = L.control.layers(basemaps, overlays, {collapsed: true}).addTo(map);

        /* Control de coordenadas */
        var coordenadas = addCoordControl();
        coordenadas.addTo(map);
        
        document.getElementById('coord-format').addEventListener('change', function() {
            map.fire('mousemove', {latlng: map.getCenter()});
        });

        // #region BOTONES

        /* ---------------------------------------------------------------------------------------------- */
        // Botón para cargar capas
        /* ---------------------------------------------------------------------------------------------- */
        var AddLayerButton = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function(map) {
            var container = L.DomUtil.create('div', 'leaflet-bar add-layer-control-container');
            container.style.marginTop = '60px';

            var btn = L.DomUtil.create('button', 'add-layer-control', container);
            btn.style.display = 'block';
            btn.style.width = '40px';
            btn.style.height = '40px';
            btn.style.background = `white url('imagenes/layer_3419447.png') no-repeat center center`;
            btn.style.backgroundSize = '24px 24px';
            btn.title = 'Agregar capa';
            btn.style.border = '1px solid #ccc';
            btn.style.boxShadow = '0 1px 5px rgba(0,0,0,0.4)';
            btn.style.borderRadius = '4px';
            btn.style.cursor = 'pointer';

            L.DomEvent.disableClickPropagation(btn);

            btn.addEventListener('click', function() {
                let modalBg = document.createElement('div');
                modalBg.style.position = 'fixed';
                modalBg.style.top = 0;
                modalBg.style.left = 0;
                modalBg.style.width = '100vw';
                modalBg.style.height = '100vh';
                modalBg.style.background = 'rgba(0,0,0,0.3)';
                modalBg.style.zIndex = 9999;

                let dialog = document.createElement('div');
                dialog.style.position = 'fixed';
                dialog.style.top = '50%';
                dialog.style.left = '50%';
                dialog.style.transform = 'translate(-50%, -50%)';
                dialog.style.background = 'white';
                dialog.style.padding = '20px';
                dialog.style.borderRadius = '8px';
                dialog.style.boxShadow = '0 2px 12px rgba(0,0,0,0.3)';
                dialog.style.minWidth = '340px';
                dialog.innerHTML = `
                <label>Tipo de capa:
                    <select id="tipo-capa">
                        <option value="GeoJSON">GeoJSON</option>
                        <option value="WMS">WMS</option>
                        <option value="WFS">WFS</option>
                    </select>
                </label>
                <div id="geojson-file-div" style="margin:8px 0;">
                    <input type="file" id="geojson-file" accept=".geojson,.json" style="width:100%;" />
                </div>
                <div id="wfs-div" style="margin:8px 0; display:none;">
                    <label>Servicio WFS:
                        <select id="wfs-servicio" style="width:100%;">
                            <option value="">Introduzca un servicio WFS</option>
                        </select>
                    </label>
                    <input type="text" id="capa-url" placeholder="URL del servicio" style="width:100%;margin-top:6px;" />
                </div>
                <div id="url-div" style="margin:8px 0;">
                    <input type="text" id="capa-url-wms" placeholder="URL del servicio" style="width:100%;" />
                </div>
                <button id="confirmar-capa" style="margin-top:10px;width:100%;">Agregar capa</button>
                <button id="cancelar-capa" style="margin-top:6px;width:100%;">Cancelar</button>
                `;

                // Cargar servicios WFS desde el archivo JSON
                let wfsServicios = [];
                function cargarServiciosWFS() {
                fetch('serviciosWFS.config.json')
                    .then(r => r.json())
                    .then(json => {
                    wfsServicios = json.WFS_Disponibles || [];
                    let select = dialog.querySelector('#wfs-servicio');
                    // Limpiar y agregar opción manual
                    select.innerHTML = `<option value="">Introduzca un servicio WFS</option>`;
                    wfsServicios.forEach((serv, idx) => {
                        let opt = document.createElement('option');
                        opt.value = idx;
                        opt.textContent = serv.nombre;
                        select.appendChild(opt);
                    });
                    // Opción manual
                    let optManual = document.createElement('option');
                    optManual.value = 'manual';
                    optManual.textContent = 'Introducir url de WFS manualmente';
                    select.appendChild(optManual);
                    });
                }

                function updateDialogFields() {
                let tipo = dialog.querySelector('#tipo-capa').value;
                dialog.querySelector('#geojson-file-div').style.display = (tipo === 'GeoJSON') ? 'block' : 'none';
                dialog.querySelector('#url-div').style.display = (tipo === 'WMS') ? 'block' : 'none';
                dialog.querySelector('#wfs-div').style.display = (tipo === 'WFS') ? 'block' : 'none';
                if (tipo === 'WFS') {
                    cargarServiciosWFS();
                    dialog.querySelector('#capa-url').value = '';
                }
                }

                dialog.querySelector('#tipo-capa').addEventListener('change', updateDialogFields);
                updateDialogFields();

                // WFS combo y url sync
                dialog.addEventListener('change', function(e) {
                    if (e.target && e.target.id === 'wfs-servicio') {
                        let idx = e.target.value;
                        let urlInput = dialog.querySelector('#capa-url');
                        if (idx === '') {
                            urlInput.value = '';
                            urlInput.readOnly = true;
                        } else if (idx === 'manual') {
                            urlInput.value = '';
                            urlInput.readOnly = false;
                            urlInput.placeholder = "Introduzca la URL del servicio WFS";
                        } else {
                            let serv = wfsServicios[parseInt(idx)];
                            urlInput.value = serv ? serv.url : '';
                            urlInput.readOnly = true;
                        }
                    }
                });

                dialog.querySelector('#confirmar-capa').onclick = function() {
                    let tipo = dialog.querySelector('#tipo-capa').value;
                    if (tipo === 'GeoJSON') {
                        agregarCapaGeoJSON(dialog.querySelector('#geojson-file'));
                    } else if (tipo === 'WMS') {
                        let url = dialog.querySelector('#capa-url-wms').value.trim();
                        if (url) agregarCapaWMS(url);
                    } else if (tipo === 'WFS') {
                        let select = dialog.querySelector('#wfs-servicio');
                        let idx = select.value;
                        let url = dialog.querySelector('#capa-url').value.trim();
                        let nombre = '';
                        if (idx === '') {
                            alert('Seleccione un servicio WFS o introduzca uno manualmente.');
                            return;
                        }
                        if (idx === 'manual') {
                        if (!url) {
                            alert('Introduzca la URL del servicio WFS.');
                            return;
                        }
                        nombre = prompt('Nombre para la capa WFS:', url) || url;
                        } else {
                        let serv = wfsServicios[parseInt(idx)];
                        nombre = serv ? serv.nombre : url;
                        }
                        if (url && nombre) agregarCapaWFS(url, nombre);
                    }
                    document.body.removeChild(modalBg);
                };

                dialog.querySelector('#cancelar-capa').onclick = function() {
                    document.body.removeChild(modalBg);
                };

                modalBg.appendChild(dialog);
                document.body.appendChild(modalBg);
            });

            return container;
            },
            onRemove: function(map) {}
        });

        map.addControl(new AddLayerButton());        

        /* ---------------------------------------------------------------------------------------------- */
        // Botón para ejecutar superposición de capas
        /* ---------------------------------------------------------------------------------------------- */
        
        var IntersectButton = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function(map) {
                var container = L.DomUtil.create('div', 'leaflet-bar add-layer-control-container');
                container.style.marginTop = '60px';

                var btn = L.DomUtil.create('button', 'add-layer-control', container);
                btn.style.display = 'block';
                btn.style.width = '40px';
                btn.style.height = '40px';
                btn.style.background = `white url('imagenes/tools.png') no-repeat center center`;
                btn.style.backgroundSize = '30px 30px';
                btn.title = 'Intersecar capas';
                btn.style.border = '1px solid #ccc';
                btn.style.boxShadow = '0 1px 5px rgba(0,0,0,0.4)';
                btn.style.borderRadius = '4px';
                btn.style.cursor = 'pointer';

                L.DomEvent.disableClickPropagation(btn);

                btn.addEventListener('click', function() {
                    let modalBg = document.createElement('div');
                    modalBg.style.position = 'fixed';
                    modalBg.style.top = 0;
                    modalBg.style.left = 0;
                    modalBg.style.width = '100vw';
                    modalBg.style.height = '100vh';
                    modalBg.style.background = 'rgba(0,0,0,0.3)';
                    modalBg.style.zIndex = 9999;

                    let dialog = document.createElement('div');
                    dialog.style.position = 'fixed';
                    dialog.style.top = '50%';
                    dialog.style.left = '50%';
                    dialog.style.transform = 'translate(-50%, -50%)';
                    dialog.style.background = 'white';
                    dialog.style.padding = '20px';
                    dialog.style.borderRadius = '8px';
                    dialog.style.boxShadow = '0 2px 12px rgba(0,0,0,0.3)';
                    dialog.style.minWidth = '320px';

                    let overlayKeys = Object.keys(overlays);
                    let capaOptions = overlayKeys.map(k => `<option value="${k}">${k}</option>`).join('');
                    dialog.innerHTML = `
                        <label>Capa de entrada:
                            <select id="capa-entrada">${capaOptions}</select>
                        </label>
                        <label style="margin-top:8px;display:block;">Capa de identificación:
                            <select id="capa-identificacion">${capaOptions}</select>
                        </label>
                        <label style="margin-top:8px;display:block;">Opciones:
                            <select id="intersect-opcion">
                                <option value="solo_intersectan">Solo los que intersectan</option>
                                <option value="todos">Todos (marcar intersección)</option>
                            </select>
                        </label>
                        <button id="ejecutar-intersect" style="margin-top:10px;width:100%;">Ejecutar</button>
                        <button id="cancelar-intersect" style="margin-top:6px;width:100%;">Cancelar</button>
                    `;

                    dialog.querySelector('#ejecutar-intersect').onclick = function() {
                        let capaEntrada = dialog.querySelector('#capa-entrada').value;
                        let capaIdent = dialog.querySelector('#capa-identificacion').value;
                        let opcion = dialog.querySelector('#intersect-opcion').value;
                        if (capaEntrada === capaIdent) {
                            alert("Debe seleccionar dos capas diferentes.");
                            return;
                        }
                        intersect(overlays[capaEntrada], overlays[capaIdent], opcion);
                        document.body.removeChild(modalBg);
                    };

                    dialog.querySelector('#cancelar-intersect').onclick = function() {
                        document.body.removeChild(modalBg);
                    };

                    modalBg.appendChild(dialog);
                    document.body.appendChild(modalBg);
                });

                return container;
            },
            onRemove: function(map) {}
        });

        map.addControl(new IntersectButton());
        
        // #endregion

        // #region CONTROL COORDENADAS MAP
        function updateCoords(e) {
            let format = document.getElementById('coord-format').value;
            let lat = e.latlng.lat, lng = e.latlng.lng;
            let coordsDiv = document.getElementById('coords');
            if (format === 'WGS84_DD') {
                coordsDiv.textContent = `Lat: ${lat.toFixed(6)}, Lng: ${lng.toFixed(6)}`;
            } else if (format === 'WGS84_DDMMSS') {
                let latDeg = Math.floor(Math.abs(lat));
                let latMin = Math.floor((Math.abs(lat) - latDeg) * 60);
                let latSec = ((Math.abs(lat) - latDeg - latMin / 60) * 3600).toFixed(2);
                let lngDeg = Math.floor(Math.abs(lng));
                let lngMin = Math.floor((Math.abs(lng) - lngDeg) * 60);
                let lngSec = ((Math.abs(lng) - lngDeg - lngMin / 60) * 3600).toFixed(2);
                coordsDiv.textContent = `Lat: ${latDeg}°${latMin}'${latSec}" ${lat < 0 ? 'S' : 'N'}, Lng: ${lngDeg}°${lngMin}'${lngSec}" ${lng < 0 ? 'W' : 'E'}`;
            } else if (format === 'WebMercator') {
                let merc = proj4('EPSG:4326', 'EPSG:3857', [lng, lat]);
                coordsDiv.textContent = `X: ${merc[0].toFixed(2)}, Y: ${merc[1].toFixed(2)}`;
            } else if (format === 'UTM') {
                let utm = latLngToUTM(lat, lng);
                coordsDiv.textContent = `Zona: ${utm.zone}S, Este: ${utm.e.toFixed(2)}, Norte: ${utm.n.toFixed(2)}`;
            }
            else if (format === 'WebMercator') {
                let merc = proj4('EPSG:4326', 'EPSG:3857', [lng, lat]);
                coordsDiv.textContent = `X: ${merc[0].toFixed(2)}, Y: ${merc[1].toFixed(2)}`;
            } else if (format === 'UTM') {
                let utm = latLngToUTM(lat, lng);
                coordsDiv.textContent = `Zona: ${utm.zone}S, Este: ${utm.e.toFixed(2)}, Norte: ${utm.n.toFixed(2)}`;
            }
        };

        

        // zonas UTM para Peru (17S, 18S, 19S), 18S Peru central
        function latLngToUTM(lat, lng) {
            var zone = Math.floor((lng + 180) / 6) + 1;
            var projStr = `+proj=utm +zone=${zone} +south +datum=WGS84 +units=m +no_defs`;
            var utm = proj4('EPSG:4326', projStr, [lng, lat]);
            return {zone: zone, e: utm[0], n: utm[1]};
        }

        // #endregion

        // #region IDENTIFY

        /* 
        * Maneja el evento de clic en el mapa para mostrar información de entidades GeoJSON y WMS.
        * @param {Object} e - Evento de clic del mapa.
        */
        map.on('click', function(e) {
            var results = [];
            var maxFieldLen = 0;
            var maxValueLen = 0;
            var maxKey = '';
            var maxValue = '';

            Object.values(overlays).forEach(function(layer) {
            if (layer instanceof L.GeoJSON) {
                layer.eachLayer(function(l) {
                if (l.getBounds && l.getBounds().contains(e.latlng)) {
                    results.push(l.feature);
                } else if (l.getLatLng && l.getLatLng().distanceTo(e.latlng) < 1) {
                    results.push(l.feature);
                }
                });
            }
            // Para WMS, salta a GetFeatureInfo()
            if (layer instanceof L.TileLayer.WMS) {
                var url = getFeatureInfoUrl(layer, e.latlng);
                if (url) {
                fetch(url)
                    .then(r => r.text())
                    .then(txt => {
                    var html = `<div class="popup-scroll">${txt}</div>`;
                    L.popup({maxWidth: 800, minWidth: 300, autoPan: true})
                        .setLatLng(e.latlng)
                        .setContent(html)
                        .openOn(map);
                    });
                }
            }
            });

            // Encuentra el campo identificador y el ancho máximo de los valores
            results.forEach(function(f) {
                var props = f.properties || {};
                Object.keys(props).forEach(function(k) {
                    if (k.length > maxFieldLen) {
                    maxFieldLen = k.length;
                    maxKey = k;
                    }
                    var val = props[k] != null ? String(props[k]) : '';
                    if (val.length > maxValueLen) {
                        maxValueLen = val.length;
                        maxValue = val;
                    }
                });
            });

            // Determina el campo identificador preferido
            function getIdField(props) {
            var keys = Object.keys(props);
            var idField = keys.find(k => /^id$/i.test(k)) ||
                      keys.find(k => /^objectid$/i.test(k)) ||
                      keys.find(k => /^fid$/i.test(k)) ||
                      keys[0];
            return idField;
            }

            if (results.length > 0) {
            // Calcula el ancho mínimo necesario para la tabla
            var charWidth = 8; // px, aproximado
            var minWidth = Math.max(300, (maxFieldLen + maxValueLen) * charWidth + 80);

            var html = `<div class="popup-scroll" style="min-width:${minWidth}px;max-width:900px;">`;
            results.forEach(function(f, i) {
                var props = f.properties || {};
                var idField = getIdField(props);
                var idValue = props[idField] !== undefined ? props[idField] : (i+1);
                html += `<b>${idField}: ${idValue}</b><table style="width:100%;table-layout:auto;">`;
                for (var k in props) {
                html += `<tr><td style="font-weight:bold;vertical-align:top;">${k}</td><td style="word-break:break-all;">${props[k]}</td></tr>`;
                }
                html += '</table><hr>';
            });
            html += '</div>';
            L.popup({maxWidth: 900, minWidth: minWidth, autoPan: true})
                .setLatLng(e.latlng)
                .setContent(html)
                .openOn(map);
            }
        });

        /* Función para manejar eventos en cada entidad del GeoJSON
        * Asocia un evento de clic a cada entidad para mostrar un popup con sus propiedades.
        * @param {Object} feature - La entidad GeoJSON.
        * @param {L.Layer} layer - La capa Leaflet asociada a la entidad.
        * @returns {void}
        */
        function onEachFeature(feature, layer) {
            layer.on('click', function(e) {
                var props = feature.properties;
                var html = '<div class="popup-scroll"><table>';
                for (var k in props) {
                    html += `<tr><td><strong>${k}</strong></td><td>${props[k]}</td></tr>`;
                }
                html += '</table></div>';
                layer.bindPopup(html).openPopup(e.latlng);
            });
        };

        // Helper para GetFeatureInfo WMS
        function getFeatureInfoUrl(layer, latlng) {
            var point = map.latLngToContainerPoint(latlng, map.getZoom());
            var size = map.getSize();
            var params = {
                request: 'GetFeatureInfo',
                service: 'WMS',
                srs: 'EPSG:4326',
                styles: '',
                transparent: true,
                version: layer.wmsParams.version,
                format: layer.wmsParams.format,
                bbox: map.getBounds().toBBoxString(),
                height: size.y,
                width: size.x,
                layers: layer.wmsParams.layers,
                query_layers: layer.wmsParams.layers,
                info_format: 'text/html'
            };
            if (params.version === '1.3.0') {
                params.crs = 'EPSG:4326';
                params.i = Math.round(point.x);
                params.j = Math.round(point.y);
            } else {
                params.srs = 'EPSG:4326';
                params.x = Math.round(point.x);
                params.y = Math.round(point.y);
            }
            var url = layer._url + L.Util.getParamString(params, layer._url, true);
            return url;
        }
        // #endregion
      
        // #region FUNCIONES
        function addBasemaps(){
            let osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '© OpenStreetMap contributors'
            });

            // Esri World Imagery (satellite)
            let esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 19,
                attribution: 'Tiles © Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            });

            // Esri World Imagery + OSM labels (mixta)
            let esriLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 19,
                attribution: 'Labels © Esri'
            });
            let esriHybrid = L.layerGroup([esriSat, esriLabels]);

            // Base layers object
            let baseLayers = {
                "OpenStreetMap": osm,
                "Satélite": esriSat,
                "Mixta": esriHybrid
            };

            return baseLayers;
        };

        function addCoordControl(){
            let coordFormat = 'WGS84'; // Default
            let coordControl = L.control({position: 'bottomleft'});
            coordControl.onAdd = function(map) {
                var div = L.DomUtil.create('div', 'coords-control');
                div.innerHTML = `
                    <select id="coord-format" style="font-size:11px;">
                        <option value="WGS84_DD">WGS84 DD (Lat,Lng)</option>
                        <option value="WGS84_DDMMSS">WGS84 DD MM SS (Lat,Lng)</option>
                        <option value="WebMercator">Web Mercator (EPSG:3857)</option>
                        <option value="UTM">UTM</option>
                    </select>
                    <div id="coords" style="font-size:11px;">Lat: -, Lng: -</div>
                `;
                L.DomEvent.disableClickPropagation(div);
                return div;
            };
            return coordControl;
        };
        
        /**
         * Agrega una capa GeoJSON al mapa a partir de un archivo seleccionado.
         * @param {HTMLInputElement} fileInput - El input de tipo file que contiene el archivo GeoJSON.
         */
        function agregarCapaGeoJSON(fileInput) {
            mostrarSpinner();
            if (!fileInput.files.length) return;
            var file = fileInput.files[0];
            var reader = new FileReader();
            reader.onload = function(e) {
            try {
                var geojson_in = JSON.parse(e.target.result);
                //var geojson = reproyectarGeoJSON(geojson_in); // Reproyectar si es necesario
                var geojson = geojson_in; // Asignar directamente si no se reproyecta
                var nombre = file.name.replace(/\.[^/.]+$/, "");
                var capa = L.geoJSON(geojson, {
                onEachFeature: "", //onEachFeature,
                /*style: {
                    color: "#1976D2",        // línea externa azul medio (sin transparencia)
                    weight: 2,
                    opacity: 1,              // sin transparencia en línea
                    fillColor: "#64B5F6",    // relleno azul claro
                    fillOpacity: 0.5         // 50% transparencia en relleno
                }*/
               style: getRandomStyle() // Estilo con color aleatorio
                });
                overlays[nombre] = capa;
                capa.addTo(map);
                updateLayerControl();
                // Hacer zoom a la capa cargada
                zoomAcapa(capa);
            } catch (err) {
                ocultarSpinner
                alert("Error al cargar el archivo GeoJSON: " + err.message);
            }
            };
            reader.readAsText(file);
            ocultarSpinner();
        };

        /**
         * Devuelve un objeto de estilo Leaflet con color de línea aleatorio (excepto blanco, amarillo y rojo).
         * @returns {Object} Objeto de estilo para Leaflet.
         */
        function getRandomStyle() {
            // Colores prohibidos en formato hexadecimal
            const forbidden = ['#ffffff', '#ffff00', '#ff0000'];
            let color;
            // Genera un color aleatorio que no sea blanco, amarillo ni rojo
            do {
                // Genera aleatoriamente H, S y L para mayor variedad
                const h = Math.floor(Math.random() * 360); // Hue: 0-359
                const s = Math.floor(40 + Math.random() * 50); // Saturation: 40-90%
                const l = Math.floor(30 + Math.random() * 50); // Lightness: 30-80%
                // Convierte HSL a RGB y luego a HEX
                function hslToHex(h, s, l) {
                    s /= 100; l /= 100;
                    let c = (1 - Math.abs(2 * l - 1)) * s;
                    let x = c * (1 - Math.abs((h / 60) % 2 - 1));
                    let m = l - c/2;
                    let rgb = [0,0,0];
                    if (h < 60) rgb = [c, x, 0];
                    else if (h < 120) rgb = [x, c, 0];
                    else if (h < 180) rgb = [0, c, x];
                    else if (h < 240) rgb = [0, x, c];
                    else if (h < 300) rgb = [x, 0, c];
                    else rgb = [c, 0, x];
                    return "#" + rgb.map(v => {
                        let hex = Math.round((v + m) * 255).toString(16);
                        return hex.padStart(2, '0');
                    }).join('');
                }
                color = hslToHex(h, s, l);
            } while (forbidden.includes(color.toLowerCase()));
            return {
                color: color,
                weight: 2,
                opacity: 1,
                fillColor: color,
                fillOpacity: 0.4
            };
        }

        /**
         * Agrega una capa WMS al mapa a partir de una URL proporcionada.
         * @param {string} url - La URL del servicio WMS.
         * @returns {void}
         */
        function agregarCapaWMS(url) {
            mostrarSpinner();
            // Extrae la URL base del WMS (sin parámetros)
            let urlBase = url.split('?')[0];
            var nombre = prompt("Nombre para la capa WMS:", urlBase);
            if (!nombre) {
                ocultarSpinner();
                return;
            }
            // Intenta extraer el parámetro 'layers' de la URL si existe
            let layersMatch = url.match(/[?&]layers=([^&]+)/i);
            let layers = layersMatch ? decodeURIComponent(layersMatch[1]) : '';
            var capa = L.tileLayer.wms(urlBase, {
                layers: layers, // Si no hay layers, el usuario debe editar esto después
                format: 'image/png',
                transparent: true,
                attribution: urlBase
            });
            overlays[nombre] = capa;
            capa.addTo(map);
            zoomAcapa(capa);
            updateLayerControl();
            ocultarSpinner();
        };

        /**
         * Agrega una capa WFS al mapa a partir de una URL proporcionada.
         * @param {string} url - La URL del servicio WFS que devuelve GeoJSON.
         * @returns {void}
         */
        function agregarCapaWFS(url, nombre) {
            mostrarSpinner();
            // Solo soporta WFS que devuelven GeoJSON directamente
            fetch(url)
            .then(r => r.json())
            .then(geojson => {
                var capa = L.geoJSON(geojson, {
                    onEachFeature: "", //onEachFeature,
                    /*style: {
                        color: "#4B006E",        // línea externa morado oscuro
                        weight: 2,
                        opacity: 1,              // sin transparencia en línea
                        fillColor: "#A259E6",    // relleno morado
                        fillOpacity: 0.5         // 50% transparencia en relleno
                    }*/
                    style: getRandomStyle() // Estilo con color aleatorio
                });
                overlays[nombre] = capa;
                capa.addTo(map);
                updateLayerControl();
                zoomAcapa(capa);
            })
            .catch(() => {
                alert("No se pudo cargar el WFS (¿devuelve GeoJSON?)");
            })
            .finally(() => ocultarSpinner());
        };        

        /* Función para actualizar el control de capas
        * Elimina todas las capas del control y las vuelve a agregar según el estado actual de overlays.
        * @returns {void}
        */
        function updateLayerControl() {
            // Remove all overlays from the control
            for (var key in overlays) {
                layerControl.removeLayer(overlays[key]);
            }
            // Add current overlays to the control
            for (var key in overlays) {
                layerControl.addOverlay(overlays[key], key);
            }
        };        
       
        /* Intersecta dos capas GeoJSON y crea una nueva capa con los resultados.
         * @param {L.GeoJSON} capaEntrada - La primera capa GeoJSON.
         * @param {L.GeoJSON} capaIdent - La segunda capa GeoJSON.
         * @param {string} opcion - La opción de intersección ("solo_intersectan" o "todos").
         */
        function intersect(capaEntrada, capaIdent, opcion) {
            mostrarSpinner();
            // Verifica que ambas capas sean GeoJSON
            if (!(capaEntrada instanceof L.GeoJSON) || !(capaIdent instanceof L.GeoJSON)) {
                alert("Solo se soporta intersección entre capas GeoJSON.");
                return;
            }

            // Obtiene los features de ambas capas
            let featuresEntrada = [];
            capaEntrada.eachLayer(l => { if (l.feature) featuresEntrada.push(l.feature); });
            let featuresIdent = [];
            capaIdent.eachLayer(l => { if (l.feature) featuresIdent.push(l.feature); });

            let intersectFeatures = [];
            let allFeatures = [];

            featuresEntrada.forEach(f1 => {
            let intersected = false;
            featuresIdent.forEach(f2 => {
                let intersection = turf.intersect(f1, f2);
                if (intersection) {
                    intersected = true;
                    // Si solo queremos los que intersectan, guardamos la intersección
                    if (opcion === "solo_intersectan") {
                        // Copia propiedades de ambas features
                        intersection.properties = Object.assign({}, f1.properties, f2.properties);
                        intersectFeatures.push(intersection);
                    }
                }
            });
                if (opcion === "todos") {
                    // Marca si intersecta o no
                    let f1copy = JSON.parse(JSON.stringify(f1));
                    f1copy.properties = Object.assign({}, f1.properties);
                    f1copy.properties._intersecta = intersected ? "Sí" : "No";
                    allFeatures.push(f1copy);
                }
            });

            let resultLayer;
            if (opcion === "solo_intersectan") {
                if (intersectFeatures.length === 0) {
                    alert("No se encontraron intersecciones.");
                    return;
            }
            // Capa con relleno rayado usando patrón SVG
            // Creamos un patrón SVG y lo usamos como fillPattern
            // Primero, creamos el patrón solo una vez y lo agregamos al DOM si no existe
            function getHatchPatternId() {
                const patternId = "hatch-pattern-red";
                if (!document.getElementById(patternId)) {
                    const svgNS = "http://www.w3.org/2000/svg";
                    const svg = document.createElementNS(svgNS, "svg");
                    svg.setAttribute("width", 0);
                    svg.setAttribute("height", 0);
                    svg.style.position = "absolute";
                    svg.style.pointerEvents = "none";
                    svg.style.left = "-9999px";
                    svg.innerHTML = `
                        <defs>
                            <pattern id="${patternId}" patternUnits="userSpaceOnUse" width="8" height="8" patternTransform="rotate(45)">
                                <rect x="0" y="0" width="8" height="8" fill="white" fill-opacity="0"/>
                                <line x1="0" y1="0" x2="0" y2="8" stroke="red" stroke-width="2"/>
                            </pattern>
                        </defs>
                    `;
                    document.body.appendChild(svg);
                }
                return patternId;
            }
            getHatchPatternId();

            resultLayer = L.geoJSON({type: "FeatureCollection", features: intersectFeatures}, {
                onEachFeature: "", //onEachFeature,
                style: function() {
                    // Usamos fillPattern con SVG si el navegador lo soporta
                    return {
                        color: "red",
                        weight: 2,
                        fillColor: "url(#hatch-pattern-red)",
                        fillOpacity: 1
                    };
                }
            });

            // Parche para Leaflet: aplicar patrón SVG como relleno
            resultLayer.eachLayer(function(layer) {
                if (layer instanceof L.Path) {
                    layer.once('add', function() {
                        try {
                            const path = layer._path;
                            if (path) {
                                path.setAttribute('fill', 'url(#hatch-pattern-red)');
                                path.setAttribute('fill-opacity', 1);
                            }
                        } catch (e) {}
                    });
                }
            });
            } else {
                resultLayer = L.geoJSON({type: "FeatureCollection", features: allFeatures}, {
                    onEachFeature: "", //onEachFeature,
                    style: function(f) {
                    return {color: f.properties._intersecta === "Sí" ? "red" : "blue"};
                    }
                });
            }

            let nombreCapa = "intersect_" + opcion + "_" + Date.now()

            overlays[nombreCapa] = resultLayer;
            resultLayer.addTo(map);
            updateLayerControl();
            zoomAcapa(resultLayer);
            ocultarSpinner();
        };

        /* Función para hacer zoom a una capa
        * Hace zoom a la capa proporcionada, expandiendo sus límites en un 20% en cada dirección.
        * Si la capa es un punto, centra el mapa en ese punto con un zoom de 15.
        * @param {L.Layer} capa - La capa a la que se le hará zoom.
        * @returns {void}
        */
        function zoomAcapa(capa) {
            if (capa.getBounds && capa.getBounds().isValid()) {
                var bounds = capa.getBounds();
                // Expand bounds by 20% in each direction
                var paddingFactor = 0.2;
                var sw = bounds.getSouthWest();
                var ne = bounds.getNorthEast();
                var latDiff = ne.lat - sw.lat;
                var lngDiff = ne.lng - sw.lng;
                var newSw = L.latLng(sw.lat - latDiff * paddingFactor, sw.lng - lngDiff * paddingFactor);
                var newNe = L.latLng(ne.lat + latDiff * paddingFactor, ne.lng + lngDiff * paddingFactor);
                var paddedBounds = L.latLngBounds(newSw, newNe);
                map.fitBounds(paddedBounds);
            } else if (capa.getLatLng) {
                map.setView(capa.getLatLng(), 15);
            }else {
                alert("La capa no tiene límites válidos para hacer zoom.");
            }
        };

        function mostrarSpinner() {
        let spinner = document.getElementById('spinner-cargando');
        if (!spinner) {
            spinner = document.createElement('div');
            spinner.id = 'spinner-cargando';
            spinner.style.position = 'fixed';
            spinner.style.top = '0';
            spinner.style.left = '0';
            spinner.style.width = '100vw';
            spinner.style.height = '100vh';
            spinner.style.background = 'rgba(255,255,255,0.1)';
            spinner.style.display = 'flex';
            spinner.style.alignItems = 'center';
            spinner.style.justifyContent = 'center';
            spinner.style.zIndex = 3000;

            let spin = document.createElement('div');
            spin.style.width = '32px';
            spin.style.height = '32px';
            spin.style.border = '4px solid #eee';
            spin.style.borderTop = '4px solid #1976D2';
            spin.style.borderRadius = '50%';
            spin.style.animation = 'spin 1s linear infinite';
            spinner.appendChild(spin);

            // Agrega la animación CSS
            let style = document.createElement('style');
            style.innerHTML = `
            @keyframes spin {
                0% { transform: rotate(0deg);}
                100% { transform: rotate(360deg);}
            }`;
            document.head.appendChild(style);

            document.body.appendChild(spinner);
        } else {
            spinner.style.display = 'flex';
        }
    };

    function ocultarSpinner() {
        let spinner = document.getElementById('spinner-cargando');
        if (spinner) spinner.style.display = 'none';
    };
    // #endregion
    </script>
</body>
</html>