<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <title>Visor Leaflet Perú</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="/libs/leaflet/leaflet.css" />
    <style>
        html, body {
            height: 100%;
            margin: 0;
            padding: 0;
            overflow-x: hidden;
        }
        #map { height: 100vh; width: 100vw; }
        .coords-control {
            background: white;
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 13px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
        }
        .popup-scroll {
            max-height: 200px;
            overflow-y: auto;
        }
        .add-layer-control {
            background: white;
            padding: 8px 12px;
            border-radius: 4px;
            box-shadow: 0 1px 5px rgba(0,0,0,0.4);
            font-size: 13px;
        }
        .add-layer-control input, .add-layer-control select, .add-layer-control button {
            margin: 2px 0;
            width: 100%;
        }
    </style>
</head>
<body>
    <div id="map"></div>
    <!-- Leaflet JS -->
    <script src="/libs/leaflet/leaflet.js"></script>
    <!-- Proj4JS for projections -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.8.0/proj4.js"></script>
    <!-- Proj4Leaflet -->
    <script src="https://unpkg.com/proj4leaflet"></script>
    <!-- turf.js -->
     <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>
    <script>
        /* Mapa y capa base */
        var map = L.map('map').setView([-9.19, -75.0152], 6);
        map.on('mousemove', updateCoords);
        
        mostrarSpinner();

        var basemaps = addBasemaps();
        basemaps["OpenStreetMap"].addTo(map);        

        /* LayerControl */
        var overlays = {};
        var layerControl = L.control.layers(basemaps, overlays, {collapsed: true}).addTo(map);

        /* Control de coordenadas */
        var coordenadas = addCoordControl();
        coordenadas.addTo(map);
        
        document.getElementById('coord-format').addEventListener('change', function() {
            map.fire('mousemove', {latlng: map.getCenter()});
        });

        ocultarSpinner();

        /* Boton de control de carga de capas - Mejorar sacando elementos a otras funciones */
        // Cargar la configuración de servicios WFS
        let serviciosWFS = [];
        fetch('serviciosWFS.config.json')
            .then(r => r.json())
            .then(json => { serviciosWFS = json.WFS_Disponibles || []; });

        var AddLayerButton = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function(map) {
            var container = L.DomUtil.create('div', 'leaflet-bar add-layer-control-container');
            container.style.marginTop = '60px';

            var btn = L.DomUtil.create('button', 'add-layer-control', container);
            btn.style.display = 'block';
            btn.style.width = '40px';
            btn.style.height = '40px';
            btn.style.background = `white url('imagenes/layer_3419447.png') no-repeat center center`;
            btn.style.backgroundSize = '24px 24px';
            btn.title = 'Agregar capa';
            btn.style.border = '1px solid #ccc';
            btn.style.boxShadow = '0 1px 5px rgba(0,0,0,0.4)';
            btn.style.borderRadius = '4px';
            btn.style.cursor = 'pointer';

            L.DomEvent.disableClickPropagation(btn);

            btn.addEventListener('click', function() {
                let modalBg = document.createElement('div');
                modalBg.style.position = 'fixed';
                modalBg.style.top = 0;
                modalBg.style.left = 0;
                modalBg.style.width = '100vw';
                modalBg.style.height = '100vh';
                modalBg.style.background = 'rgba(0,0,0,0.3)';
                modalBg.style.zIndex = 9999;

                let dialog = document.createElement('div');
                dialog.style.position = 'fixed';
                dialog.style.top = '50%';
                dialog.style.left = '50%';
                dialog.style.transform = 'translate(-50%, -50%)';
                dialog.style.background = 'white';
                dialog.style.padding = '20px';
                dialog.style.borderRadius = '8px';
                dialog.style.boxShadow = '0 2px 12px rgba(0,0,0,0.3)';
                dialog.style.minWidth = '320px';
                dialog.innerHTML = `
                <label>Tipo de capa:
                    <select id="tipo-capa">
                    <option value="GeoJSON">GeoJSON</option>
                    <option value="WMS">WMS</option>
                    <option value="WFS">WFS</option>
                    </select>
                </label>
                <div id="geojson-file-div" style="margin:8px 0;">
                    <input type="file" id="geojson-file" accept=".geojson,.json" style="width:100%;" />
                </div>
                <div id="wfs-div" style="margin:8px 0; display:none;">
                    <label>Servicio WFS:
                    <select id="wfs-servicio" style="width:100%;"></select>
                    </label>
                    <input type="text" id="wfs-url" placeholder="URL del servicio WFS" style="width:100%;margin-top:4px;" />
                </div>
                <div id="url-div" style="margin:8px 0;">
                    <input type="text" id="capa-url" placeholder="URL del servicio" style="width:100%;" />
                </div>
                <button id="confirmar-capa" style="margin-top:10px;width:100%;">Agregar capa</button>
                <button id="cancelar-capa" style="margin-top:6px;width:100%;">Cancelar</button>
                `;

                // Inicializar combo WFS
                function fillWFSCombo() {
                let wfsCombo = dialog.querySelector('#wfs-servicio');
                if (!wfsCombo) return;
                wfsCombo.innerHTML = '';
                if (serviciosWFS && serviciosWFS.length > 0) {
                    serviciosWFS.forEach(s => {
                    let opt = document.createElement('option');
                    opt.value = s.url;
                    opt.textContent = s.nombre;
                    wfsCombo.appendChild(opt);
                    });
                }
                // Opción manual
                let optManual = document.createElement('option');
                optManual.value = '__manual__';
                optManual.textContent = 'Introducir url de WFS manualmente';
                wfsCombo.appendChild(optManual);
                }

                // Mostrar/ocultar campos según tipo de capa
                function updateDialogFields() {
                let tipo = dialog.querySelector('#tipo-capa').value;
                dialog.querySelector('#geojson-file-div').style.display = (tipo === 'GeoJSON') ? 'block' : 'none';
                dialog.querySelector('#url-div').style.display = (tipo === 'WMS') ? 'block' : 'none';
                dialog.querySelector('#wfs-div').style.display = (tipo === 'WFS') ? 'block' : 'none';
                if (tipo === 'WFS') {
                    fillWFSCombo();
                    // Por defecto, selecciona el primer servicio
                    let wfsCombo = dialog.querySelector('#wfs-servicio');
                    if (wfsCombo) {
                    wfsCombo.selectedIndex = 0;
                    let url = wfsCombo.value;
                    let urlInput = dialog.querySelector('#wfs-url');
                    if (url !== '__manual__') {
                        urlInput.value = url;
                        urlInput.readOnly = true;
                    } else {
                        urlInput.value = '';
                        urlInput.readOnly = false;
                    }
                    }
                }
                }

                // Cambiar url cuando cambia el combo WFS
                dialog.addEventListener('change', function(e) {
                if (e.target && e.target.id === 'wfs-servicio') {
                    let wfsCombo = dialog.querySelector('#wfs-servicio');
                    let urlInput = dialog.querySelector('#wfs-url');
                    let url = wfsCombo.value;
                    if (url === '__manual__') {
                    urlInput.value = '';
                    urlInput.readOnly = false;
                    } else {
                    urlInput.value = url;
                    urlInput.readOnly = true;
                    }
                }
                if (e.target && e.target.id === 'tipo-capa') {
                    updateDialogFields();
                }
                });

                updateDialogFields();

                dialog.querySelector('#confirmar-capa').onclick = function() {
                let tipo = dialog.querySelector('#tipo-capa').value;
                if (tipo === 'GeoJSON') {
                    agregarCapaGeoJSON(dialog.querySelector('#geojson-file'));
                } else if (tipo === 'WMS') {
                    let url = dialog.querySelector('#capa-url').value.trim();
                    if (url) agregarCapaWMS(url);
                } else if (tipo === 'WFS') {
                    let wfsCombo = dialog.querySelector('#wfs-servicio');
                    let urlInput = dialog.querySelector('#wfs-url');
                    let url = urlInput.value.trim();
                    let nombre = '';
                    if (wfsCombo.value === '__manual__') {
                    nombre = prompt("Nombre para la capa WFS:", url) || url;
                    } else {
                    nombre = wfsCombo.options[wfsCombo.selectedIndex].textContent;
                    }
                    if (url) agregarCapaWFS(url, nombre);
                }
                document.body.removeChild(modalBg);
                };

                dialog.querySelector('#cancelar-capa').onclick = function() {
                document.body.removeChild(modalBg);
                };

                modalBg.appendChild(dialog);
                document.body.appendChild(modalBg);
            });

            return container;
            },
            onRemove: function(map) {}
        });

        map.addControl(new AddLayerButton());

        

        /* ---------------------------------------------------------------------------------------------- */
        // Botón para ejecutar superposición de capas
        /* ---------------------------------------------------------------------------------------------- */
        
        var IntersectButton = L.Control.extend({
            options: { position: 'topright' },
            onAdd: function(map) {
                var container = L.DomUtil.create('div', 'leaflet-bar intersect-layer-control-container');
                container.style.marginTop = '110px'; // Cambia el margen para evitar superposición

                var btn = L.DomUtil.create('button', 'add-layer-control', container);
                btn.style.display = 'block';
                btn.style.width = '40px';
                btn.style.height = '40px';
                btn.style.background = `white url('imagenes/tools.png') no-repeat center center`;
                btn.style.backgroundSize = '30px 30px';
                btn.title = 'Intersecar capas';
                btn.style.border = '1px solid #ccc';
                btn.style.boxShadow = '0 1px 5px rgba(0,0,0,0.4)';
                btn.style.borderRadius = '4px';
                btn.style.cursor = 'pointer';

                L.DomEvent.disableClickPropagation(btn);

                btn.addEventListener('click', function() {
                    let modalBg = document.createElement('div');
                    modalBg.style.position = 'fixed';
                    modalBg.style.top = 0;
                    modalBg.style.left = 0;
                    modalBg.style.width = '100vw';
                    modalBg.style.height = '100vh';
                    modalBg.style.background = 'rgba(0,0,0,0.3)';
                    modalBg.style.zIndex = 9999;

                    let dialog = document.createElement('div');
                    dialog.style.position = 'fixed';
                    dialog.style.top = '50%';
                    dialog.style.left = '50%';
                    dialog.style.transform = 'translate(-50%, -50%)';
                    dialog.style.background = 'white';
                    dialog.style.padding = '20px';
                    dialog.style.borderRadius = '8px';
                    dialog.style.boxShadow = '0 2px 12px rgba(0,0,0,0.3)';
                    dialog.style.minWidth = '320px';

                    let overlayKeys = Object.keys(overlays);
                    let capaOptions = overlayKeys.map(k => `<option value="${k}">${k}</option>`).join('');
                    dialog.innerHTML = `
                        <label>Capa de entrada:
                            <select id="capa-entrada">${capaOptions}</select>
                        </label>
                        <label style="margin-top:8px;display:block;">Capa de identificación:
                            <select id="capa-identificacion">${capaOptions}</select>
                        </label>
                        <label style="margin-top:8px;display:block;">Opciones:
                            <select id="intersect-opcion">
                                <option value="solo_intersectan">Solo los que intersectan</option>
                                <option value="todos">Todos (marcar intersección)</option>
                            </select>
                        </label>
                        <button id="ejecutar-intersect" style="margin-top:10px;width:100%;">Ejecutar</button>
                        <button id="cancelar-intersect" style="margin-top:6px;width:100%;">Cancelar</button>
                    `;

                    dialog.querySelector('#ejecutar-intersect').onclick = function() {
                        let capaEntrada = dialog.querySelector('#capa-entrada').value;
                        let capaIdent = dialog.querySelector('#capa-identificacion').value;
                        let opcion = dialog.querySelector('#intersect-opcion').value;
                        if (capaEntrada === capaIdent) {
                            alert("Debe seleccionar dos capas diferentes.");
                            return;
                        }
                        intersect(overlays[capaEntrada], overlays[capaIdent], opcion);
                        document.body.removeChild(modalBg);
                    };

                    dialog.querySelector('#cancelar-intersect').onclick = function() {
                        document.body.removeChild(modalBg);
                    };

                    modalBg.appendChild(dialog);
                    document.body.appendChild(modalBg);
                });

                return container;
            },
            onRemove: function(map) {}
        });

        map.addControl(new IntersectButton());
        
        function updateCoords(e) {
            let format = document.getElementById('coord-format').value;
            let lat = e.latlng.lat, lng = e.latlng.lng;
            let coordsDiv = document.getElementById('coords');
            if (format === 'WGS84_DD') {
                coordsDiv.textContent = `Lat: ${lat.toFixed(6)}, Lng: ${lng.toFixed(6)}`;
            } else if (format === 'WGS84_DDMMSS') {
                let latDeg = Math.floor(Math.abs(lat));
                let latMin = Math.floor((Math.abs(lat) - latDeg) * 60);
                let latSec = ((Math.abs(lat) - latDeg - latMin / 60) * 3600).toFixed(2);
                let lngDeg = Math.floor(Math.abs(lng));
                let lngMin = Math.floor((Math.abs(lng) - lngDeg) * 60);
                let lngSec = ((Math.abs(lng) - lngDeg - lngMin / 60) * 3600).toFixed(2);
                coordsDiv.textContent = `Lat: ${latDeg}°${latMin}'${latSec}" ${lat < 0 ? 'S' : 'N'}, Lng: ${lngDeg}°${lngMin}'${lngSec}" ${lng < 0 ? 'W' : 'E'}`;
            } else if (format === 'WebMercator') {
                let merc = proj4('EPSG:4326', 'EPSG:3857', [lng, lat]);
                coordsDiv.textContent = `X: ${merc[0].toFixed(2)}, Y: ${merc[1].toFixed(2)}`;
            } else if (format === 'UTM') {
                let utm = latLngToUTM(lat, lng);
                coordsDiv.textContent = `Zona: ${utm.zone}S, Este: ${utm.e.toFixed(2)}, Norte: ${utm.n.toFixed(2)}`;
            }
            else if (format === 'WebMercator') {
                let merc = proj4('EPSG:4326', 'EPSG:3857', [lng, lat]);
                coordsDiv.textContent = `X: ${merc[0].toFixed(2)}, Y: ${merc[1].toFixed(2)}`;
            } else if (format === 'UTM') {
                let utm = latLngToUTM(lat, lng);
                coordsDiv.textContent = `Zona: ${utm.zone}S, Este: ${utm.e.toFixed(2)}, Norte: ${utm.n.toFixed(2)}`;
            }
        };

        

        // zonas UTM para Peru (17S, 18S, 19S), 18S Peru central
        function latLngToUTM(lat, lng) {
            var zone = Math.floor((lng + 180) / 6) + 1;
            var projStr = `+proj=utm +zone=${zone} +south +datum=WGS84 +units=m +no_defs`;
            var utm = proj4('EPSG:4326', projStr, [lng, lat]);
            return {zone: zone, e: utm[0], n: utm[1]};
        }

        

        /*  
        * Evento de clic en el mapa para mostrar información de entidades
        * Recorre todas las capas superpuestas y verifica si el punto clicado está dentro de sus límites.
        * Si es así, muestra un popup con la información de las entidades.
        * Para capas WMS, intenta obtener información usando GetFeatureInfo.
        */
        map.on('click', function(e) {
            var results = [];
            Object.values(overlays).forEach(function(layer) {
                if (layer instanceof L.GeoJSON) {
                    layer.eachLayer(function(l) {
                        if (l.getBounds && l.getBounds().contains(e.latlng)) {
                            results.push(l.feature);
                        } else if (l.getLatLng && l.getLatLng().distanceTo(e.latlng) < 10) {
                            results.push(l.feature);
                        }
                    });
                }
                // For WMS, try GetFeatureInfo
                if (layer instanceof L.TileLayer.WMS) {
                    var url = getFeatureInfoUrl(layer, e.latlng);
                    if (url) {
                        fetch(url)
                            .then(r => r.text())
                            .then(txt => {
                                var html = `<div class="popup-scroll">${txt}</div>`;
                                L.popup({maxWidth: 400})
                                    .setLatLng(e.latlng)
                                    .setContent(html)
                                    .openOn(map);
                            });
                    }
                }
            });
            if (results.length > 0) {
                var html = '<div class="popup-scroll">';
                results.forEach(function(f, i) {
                    html += `<b>Entidad ${i+1}</b><table>`;
                    for (var k in f.properties) {
                        html += `<tr><td><strong>${k}</strong></td><td>${f.properties[k]}</td></tr>`;
                    }
                    html += '</table><hr>';
                });
                html += '</div>';
                L.popup({maxWidth: 400})
                    .setLatLng(e.latlng)
                    .setContent(html)
                    .openOn(map);
            }
        });

        /* Función para manejar eventos en cada entidad del GeoJSON
        * Asocia un evento de clic a cada entidad para mostrar un popup con sus propiedades.
        * @param {Object} feature - La entidad GeoJSON.
        * @param {L.Layer} layer - La capa Leaflet asociada a la entidad.
        * @returns {void}
        */
        function onEachFeature(feature, layer) {
            layer.on('click', function(e) {
                var props = feature.properties;
                var html = '<div class="popup-scroll"><table>';
                for (var k in props) {
                    html += `<tr><td><strong>${k}</strong></td><td>${props[k]}</td></tr>`;
                }
                html += '</table></div>';
                layer.bindPopup(html).openPopup(e.latlng);
            });
        };

        // Helper para GetFeatureInfo WMS
        function getFeatureInfoUrl(layer, latlng) {
            var point = map.latLngToContainerPoint(latlng, map.getZoom());
            var size = map.getSize();
            var params = {
                request: 'GetFeatureInfo',
                service: 'WMS',
                srs: 'EPSG:4326',
                styles: '',
                transparent: true,
                version: layer.wmsParams.version,
                format: layer.wmsParams.format,
                bbox: map.getBounds().toBBoxString(),
                height: size.y,
                width: size.x,
                layers: layer.wmsParams.layers,
                query_layers: layer.wmsParams.layers,
                info_format: 'text/html'
            };
            if (params.version === '1.3.0') {
                params.crs = 'EPSG:4326';
                params.i = Math.round(point.x);
                params.j = Math.round(point.y);
            } else {
                params.srs = 'EPSG:4326';
                params.x = Math.round(point.x);
                params.y = Math.round(point.y);
            }
            var url = layer._url + L.Util.getParamString(params, layer._url, true);
            return url;
        }

        // Remove layer from overlays and update control when removed from map
        map.on('layerremove', function(e) {
            for (var key in overlays) {
                if (overlays[key] === e.layer) {
                    delete overlays[key];
                    updateLayerControl();
                    break;
                }
            }
        });
        map.on('layeradd', function(e) {
            updateLayerControl();
        });

        function addBasemaps(){
            let osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                maxZoom: 19,
                attribution: '© OpenStreetMap contributors'
            });

            // Esri World Imagery (satellite)
            let esriSat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 19,
                attribution: 'Tiles © Esri &mdash; Source: Esri, i-cubed, USDA, USGS, AEX, GeoEye, Getmapping, Aerogrid, IGN, IGP, UPR-EGP, and the GIS User Community'
            });

            // Esri World Imagery + OSM labels (mixta)
            let esriLabels = L.tileLayer('https://services.arcgisonline.com/ArcGIS/rest/services/Reference/World_Boundaries_and_Places/MapServer/tile/{z}/{y}/{x}', {
                maxZoom: 19,
                attribution: 'Labels © Esri'
            });
            let esriHybrid = L.layerGroup([esriSat, esriLabels]);

            // Base layers object
            let baseLayers = {
                "OpenStreetMap": osm,
                "Satélite": esriSat,
                "Mixta": esriHybrid
            };

            return baseLayers;
        };

        function addCoordControl(){
            let coordFormat = 'WGS84'; // Default
            let coordControl = L.control({position: 'bottomleft'});
            coordControl.onAdd = function(map) {
                var div = L.DomUtil.create('div', 'coords-control');
                div.innerHTML = `
                    <select id="coord-format" style="font-size:11px;">
                        <option value="WGS84_DD">WGS84 DD (Lat,Lng)</option>
                        <option value="WGS84_DDMMSS">WGS84 DD MM SS (Lat,Lng)</option>
                        <option value="WebMercator">Web Mercator (EPSG:3857)</option>
                        <option value="UTM">UTM</option>
                    </select>
                    <div id="coords" style="font-size:11px;">Lat: -, Lng: -</div>
                `;
                L.DomEvent.disableClickPropagation(div);
                return div;
            };
            return coordControl;
        };

        /* ---------------------------------------------------------------------------------------------- */
        // Función para agregar capa GeoJSON
        /**
         * Agrega una capa GeoJSON al mapa a partir de un archivo seleccionado.
         * @param {HTMLInputElement} fileInput - El input de tipo file que contiene el archivo GeoJSON.
         */
        function agregarCapaGeoJSON(fileInput) {
            mostrarSpinner();
            if (!fileInput.files.length) return;
            var file = fileInput.files[0];
            var reader = new FileReader();
            reader.onload = function(e) {
            try {
                var geojson_in = JSON.parse(e.target.result);
                //var geojson = reproyectarGeoJSON(geojson_in); // Reproyectar si es necesario
                var geojson = geojson_in; // Asignar directamente si no se reproyecta
                var nombre = file.name.replace(/\.[^/.]+$/, "");
                var capa = L.geoJSON(geojson, {
                onEachFeature: onEachFeature,
                style: {
                    color: "#1976D2",        // línea externa azul medio (sin transparencia)
                    weight: 2,
                    opacity: 1,              // sin transparencia en línea
                    fillColor: "#64B5F6",    // relleno azul claro
                    fillOpacity: 0.5         // 50% transparencia en relleno
                }
                });
                overlays[nombre] = capa;
                capa.addTo(map);
                updateLayerControl();
                // Hacer zoom a la capa cargada
                zoomAcapa(capa);
            } catch (err) {
                ocultarSpinner
                alert("Error al cargar el archivo GeoJSON: " + err.message);
            }
            };
            reader.readAsText(file);
            ocultarSpinner();
        };

        /**
         * Reproyecta una capa GeoJSON a EPSG:4326 (Leaflet por defecto) si no coincide el sistema de coordenadas.
         * @param {Object} geojson - Objeto GeoJSON.
         * @returns {Object} - GeoJSON reproyectado a EPSG:4326.
         */
        function reproyectarGeoJSON(geojson) {
            try {
                // Verifica si proj4 está cargado
                if (typeof proj4 === 'undefined') {
                    throw new Error("Proj4JS no está cargado. Asegúrate de incluir la librería.");
                }
            
                // Detecta CRS en el GeoJSON (soporta crs.properties.name o crs.properties.code)
                let crs = geojson.crs && (geojson.crs.properties && (geojson.crs.properties.name || geojson.crs.properties.code));
                if (!crs) return geojson; // No CRS declarado, se asume EPSG:4326

                let srcCrsRaw = geojson.crs.properties.name || geojson.crs.properties.code || '';
                let srcCrs = srcCrsRaw.toUpperCase();

                // Extrae el código EPSG de URN como "urn:ogc:def:crs:EPSG::32717"
                let epsgMatch = srcCrs.match(/EPSG(?::|::)(\d+)/);
                let srcProj = '';
                if (epsgMatch && epsgMatch[1]) {
                    srcProj = 'EPSG:' + epsgMatch[1];
                } else if (srcCrs.startsWith('EPSG:')) {
                    srcProj = srcCrs;
                } else {
                    srcProj = srcCrs; // fallback
                }

                if (srcProj === 'EPSG:4326') return geojson; // Ya está en WGS84

                let dstProj = 'EPSG:4326';

                function reproyectarCoords(coords) {
                    if (typeof coords[0] === 'number') {
                        // GeoJSON: [lng, lat], Proj4 espera [x, y]
                        var result = proj4(srcProj, dstProj, [coords[0], coords[1]]);
                        // Asegura que el resultado sea [lng, lat]
                        return [result[0], result[1]];
                    } else {
                        return coords.map(reproyectarCoords);
                    }
                }

                function reproyectarFeature(f) {
                    let g = f.geometry;
                    if (!g || !g.coordinates) return f; // Si no hay geometría o coordenadas, retorna el feature original
                    let reprojGeom = Object.assign({}, g);
                    reprojGeom.coordinates = reproyectarCoords(g.coordinates);
                    return Object.assign({}, f, { geometry: reprojGeom });
                }

                if (geojson.type === 'FeatureCollection') {
                    return {
                        type: 'FeatureCollection',
                        features: geojson.features.map(reproyectarFeature)
                    };
                } else if (geojson.type === 'Feature') {
                    return reproyectarFeature(geojson);
                } else if (geojson.type === 'GeometryCollection') {
                    return {
                        type: 'GeometryCollection',
                        geometries: geojson.geometries.map(g => {
                            let reprojGeom = Object.assign({}, g);
                            reprojGeom.coordinates = reproyectarCoords(g.coordinates);
                            return reprojGeom;
                        })
                    };
                }
                return geojson;
            } catch (err) {
                console.error("Error al reproyectar GeoJSON: " + err.message);
                return geojson; // Retorna el GeoJSON original si hay error
            }
        }

        /**
         * Agrega una capa WMS al mapa a partir de una URL proporcionada.
         * @param {string} url - La URL del servicio WMS.
         *  * @returns {void}
         */
        function agregarCapaWMS(url) {
            mostrarSpinner();
            var nombre = prompt("Nombre para la capa WMS:", url);
            if (!nombre) return;
            var capa = L.tileLayer.wms(url, {
                layers: '', // El usuario debe editar esto después
                format: 'image/png',
                transparent: true,
                attribution: url
            });
            overlays[nombre] = capa;
            capa.addTo(map);
            updateLayerControl();
            ocultarSpinner();
        };

        /**
         * Agrega una capa WFS al mapa a partir de una URL proporcionada.
         * @param {string} url - La URL del servicio WFS que devuelve GeoJSON.
         * @returns {void}
         */        
        function agregarCapaWFS(url, nombre) {
            mostrarSpinner();
            if (!nombre) nombre = "WFS";
            fetch(url)
            .then(r => r.json())
            .then(geojson => {
                var color = getRandomColor(true);
                var capa = L.geoJSON(geojson, {
                    onEachFeature: onEachFeature,                    
                    style: {
                        color: color,
                        weight: 2,
                        opacity: 1,
                        fillColor: color/*,
                        fillOpacity: 0.5*/
                    }
                });
                overlays[nombre] = capa;
                capa.addTo(map);
                updateLayerControl();
                zoomAcapa(capa);
            })
            .catch(() => {
                alert("No se pudo cargar el WFS (¿devuelve GeoJSON?)");
            })
            .finally(() => ocultarSpinner());
        }
        
        function getRandomColor(rgba) {
            // Genera un color aleatorio en formato hexadecimal o rgba según el parámetro
            var r = Math.floor(Math.random() * 256);
            var g = Math.floor(Math.random() * 256);
            var b = Math.floor(Math.random() * 256);
            if (rgba === true) {
                return `rgba(${r},${g},${b},0.5)`;
            } else {
                // Hexadecimal
                return (
                    "#" +
                    r.toString(16).padStart(2, "0") +
                    g.toString(16).padStart(2, "0") +
                    b.toString(16).padStart(2, "0")
                ).toUpperCase();
            }
        };
        /* Función para actualizar el control de capas
            * Elimina todas las capas del control y las vuelve a agregar según el estado actual de overlays.
            * @returns {void}
        */
        function updateLayerControl() {
            // Remove all overlays from the control
            for (var key in overlays) {
                layerControl.removeLayer(overlays[key]);
            }
            // Add current overlays to the control
            for (var key in overlays) {
                layerControl.addOverlay(overlays[key], key);
            }
        };

        /* Función para hacer zoom a una capa
            * Hace zoom a la capa proporcionada, expandiendo sus límites en un 20% en cada dirección.
            * Si la capa es un punto, centra el mapa en ese punto con un zoom de 15.
            * @param {L.Layer} capa - La capa a la que se le hará zoom.
            * @returns {void}
        */
        function zoomAcapa(capa) {
            if (capa.getBounds && capa.getBounds().isValid()) {
                var bounds = capa.getBounds();
                // Expand bounds by 20% in each direction
                var paddingFactor = 0.2;
                var sw = bounds.getSouthWest();
                var ne = bounds.getNorthEast();
                var latDiff = ne.lat - sw.lat;
                var lngDiff = ne.lng - sw.lng;
                var newSw = L.latLng(sw.lat - latDiff * paddingFactor, sw.lng - lngDiff * paddingFactor);
                var newNe = L.latLng(ne.lat + latDiff * paddingFactor, ne.lng + lngDiff * paddingFactor);
                var paddedBounds = L.latLngBounds(newSw, newNe);
                map.fitBounds(paddedBounds);
            } else if (capa.getLatLng) {
                map.setView(capa.getLatLng(), 15);
            }
        };
       
        function intersect(capaEntrada, capaIdent, opcion) {
            mostrarSpinner();
            // Verifica que ambas capas sean GeoJSON
            if (!(capaEntrada instanceof L.GeoJSON) || !(capaIdent instanceof L.GeoJSON)) {
                alert("Solo se soporta intersección entre capas GeoJSON.");
                return;
            }

            // Obtiene los features de ambas capas
            let featuresEntrada = [];
            capaEntrada.eachLayer(l => { if (l.feature) featuresEntrada.push(l.feature); });
            let featuresIdent = [];
            capaIdent.eachLayer(l => { if (l.feature) featuresIdent.push(l.feature); });

            let intersectFeatures = [];
            let allFeatures = [];

            featuresEntrada.forEach(f1 => {
            let intersected = false;
            featuresIdent.forEach(f2 => {
                let intersection = turf.intersect(f1, f2);
                if (intersection) {
                    intersected = true;
                    // Si solo queremos los que intersectan, guardamos la intersección
                    if (opcion === "solo_intersectan") {
                        // Copia propiedades de ambas features
                        intersection.properties = Object.assign({}, f1.properties, f2.properties);
                        intersectFeatures.push(intersection);
                    }
                }
            });
                if (opcion === "todos") {
                    // Marca si intersecta o no
                    let f1copy = JSON.parse(JSON.stringify(f1));
                    f1copy.properties = Object.assign({}, f1.properties);
                    f1copy.properties._intersecta = intersected ? "Sí" : "No";
                    allFeatures.push(f1copy);
                }
            });

            let resultLayer;
            let nombreCapa;
            if (opcion === "solo_intersectan") {
                if (intersectFeatures.length === 0) {
                    alert("No se encontraron intersecciones.");
                    return;
            }
            nombreCapa = "Intersección";
            resultLayer = L.geoJSON({type: "FeatureCollection", features: intersectFeatures}, {onEachFeature: onEachFeature, style: {color: "red"}});
            } else {
            nombreCapa = "Marcado intersección";
            resultLayer = L.geoJSON({type: "FeatureCollection", features: allFeatures}, {
                onEachFeature: onEachFeature,
                style: function(f) {
                return {color: f.properties._intersecta === "Sí" ? "red" : "blue"};
                }
            });
            }

            overlays[nombreCapa] = resultLayer;
            resultLayer.addTo(map);
            updateLayerControl();
            zoomAcapa(resultLayer);
            ocultarSpinner();
        };

        /* Función para hacer zoom a una capa
            * Hace zoom a la capa proporcionada, expandiendo sus límites en un 20% en cada dirección.
            * Si la capa es un punto, centra el mapa en ese punto con un zoom de 15.
            * @param {L.Layer} capa - La capa a la que se le hará zoom.
            * @returns {void}
        */
        function zoomAcapa(capa) {
            if (capa.getBounds && capa.getBounds().isValid()) {
                var bounds = capa.getBounds();
                // Expand bounds by 20% in each direction
                var paddingFactor = 0.2;
                var sw = bounds.getSouthWest();
                var ne = bounds.getNorthEast();
                var latDiff = ne.lat - sw.lat;
                var lngDiff = ne.lng - sw.lng;
                var newSw = L.latLng(sw.lat - latDiff * paddingFactor, sw.lng - lngDiff * paddingFactor);
                var newNe = L.latLng(ne.lat + latDiff * paddingFactor, ne.lng + lngDiff * paddingFactor);
                var paddedBounds = L.latLngBounds(newSw, newNe);
                map.fitBounds(paddedBounds);
            } else if (capa.getLatLng) {
                map.setView(capa.getLatLng(), 15);
            }
        };

        function mostrarSpinner() {
        let spinner = document.getElementById('spinner-cargando');
        if (!spinner) {
            spinner = document.createElement('div');
            spinner.id = 'spinner-cargando';
            spinner.style.position = 'fixed';
            spinner.style.top = '0';
            spinner.style.left = '0';
            spinner.style.width = '100vw';
            spinner.style.height = '100vh';
            spinner.style.background = 'rgba(255,255,255,0.1)';
            spinner.style.display = 'flex';
            spinner.style.alignItems = 'center';
            spinner.style.justifyContent = 'center';
            spinner.style.zIndex = 3000;

            let spin = document.createElement('div');
            spin.style.width = '32px';
            spin.style.height = '32px';
            spin.style.border = '4px solid #eee';
            spin.style.borderTop = '4px solid #1976D2';
            spin.style.borderRadius = '50%';
            spin.style.animation = 'spin 1s linear infinite';
            spinner.appendChild(spin);

            // Agrega la animación CSS
            let style = document.createElement('style');
            style.innerHTML = `
            @keyframes spin {
                0% { transform: rotate(0deg);}
                100% { transform: rotate(360deg);}
            }`;
            document.head.appendChild(style);

            document.body.appendChild(spinner);
        } else {
            spinner.style.display = 'flex';
        }
    };

    function ocultarSpinner() {
        let spinner = document.getElementById('spinner-cargando');
        if (spinner) spinner.style.display = 'none';
    }
        
    </script>
</body>
</html>